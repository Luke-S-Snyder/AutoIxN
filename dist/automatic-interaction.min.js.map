{"version":3,"file":"automatic-interaction.min.js","sources":["../src/state/constants.js","../src/util/axis-parsers.js","../src/util/transform.js","../src/state/view-state.js","../src/util/attribute-parsers.js","../node_modules/svg-path-parser/parser.js","../node_modules/svg-path-parser/index.js","../src/orchestration/inspect.js","../src/orchestration/orchestrate.js","../src/util/legend-parsers.js","../src/hydrate.js"],"sourcesContent":["export const Selection = 'selection';\nexport const Zoom = 'zoom';\nexport const Pan = 'pan';\nexport const Filter = 'filter';\nexport const Sort = 'sort';\nexport const Brush = 'brush';\nexport const Annotate = 'annotate';\nexport const Arrange = 'arrange';\n\nexport const Scroll = 'scroll';\nexport const DoubleClick = 'dblclick';\nexport const MouseDown = 'mousedown';\nexport const MouseUp = 'mouseup';\nexport const Shift = 'shift';\nexport const Meta = 'meta';\nexport const MouseOver = 'mouseover';\nexport const MouseLeave = 'mouseleave';\n\nexport const Tick = 'tick';\nexport const TickDomain = 'domain';\nexport const Legend = 'legend';\nexport const Grid = 'grid';\nexport const Label = 'label';\nexport const Background = 'background';\nexport const Foreground = 'foreground';\n\nexport const DefaultSvgId = 'svgPlot';\nexport const SvgContainer = 'svg';\nexport const SvgGroup = 'g';\nexport const Circle = 'circle';\nexport const Ellipse = 'ellipse';\nexport const Line = 'line';\nexport const Polygon = 'polygon';\nexport const Polyline = 'polyline';\nexport const Rect = 'rect';\nexport const Path = 'path';\nexport const Text = 'text';\n","import { Tick } from \"../state/constants\";\nimport { min, max } from 'd3-array';\n\nexport function groupLabels(state) {\n    for (let i = 0; i < state.axisTextMarks.length; ++i) {\n        let xOffset = (state.axisTextMarks[i].clientRect.left + state.axisTextMarks[i].clientRect.right) / 2;\n        let yOffset = (state.axisTextMarks[i].clientRect.top + state.axisTextMarks[i].clientRect.bottom) / 2;\n\n        let xMin = 0, yMin = 0;\n        for (let j = 0; j < state.xAxis.ticks.length; ++j) {\n            if (Math.abs(xOffset - state.xAxis.ticks[j]['offset']) < Math.abs(xOffset - state.xAxis.ticks[xMin]['offset'])) {\n                xMin = j;\n            }\n        }\n        \n        for (let j = 0; j < state.yAxis.ticks.length; ++j) {\n            if (Math.abs(yOffset - state.yAxis.ticks[j]['offset']) < Math.abs(yOffset - state.yAxis.ticks[yMin]['offset'])) {\n                yMin = j;\n            }\n        }\n\n        Math.abs(xOffset - state.xAxis.ticks[xMin]['offset']) < Math.abs(yOffset - state.yAxis.ticks[yMin]['offset']) ? \n        state.xAxis.ticks[xMin]['label'] = state.axisTextMarks[i] :\n        state.yAxis.ticks[yMin]['label'] = state.axisTextMarks[i];\n\n        state.axisTextMarks[i].setAttribute('class', Tick);\n    }\n}\n\nexport function groupAxis(axis, index) {\n    let positionMap = { };\n\n    for (let i = 0; i < axis.ticks.length; ++i) {\n        let offset = axis.ticks[i].clientRect[index];\n        axis.ticks[i].setAttribute('class', (index === 'left' ? 'x-axis' : 'y-axis') + ' tick');\n\n        offset in positionMap \n        ? positionMap[offset]['ticks'].push(axis.ticks[i]) \n        : positionMap[offset] = { 'label': null, 'ticks': [axis.ticks[i]] };\n    }\n\n    axis.ticks = [];\n    for (const [key, value] of Object.entries(positionMap)) {\n        value['offset'] = +key;\n        axis.ticks.push(value);\n    }\n\n    axis.ticks.sort((first, second) => +first['offset'] < +second['offset'] ? -1 : (+first['offset'] > +second['offset'] ? 1 : 0))\n}\n\nexport function computeDomain(axis) {\n    for (const [_, value] of Object.entries(axis.ticks)) {\n        let formatVal = value['label'].__data__ || +value['label'].__data__ === 0 \n        ? value['label'].__data__ \n        : isNaN(parseInt(value['label'].innerHTML)) \n        ? value['label'].innerHTML\n        : +(value['label'].innerHTML.replace(/,/g, ''));\n\n        if (typeof formatVal === \"string\") {\n            axis.ordinal.push(formatVal);\n        } else {\n            axis.domain[0] = axis.domain[0] === null ? formatVal : min([axis.domain[0], formatVal]);\n            axis.domain[1] = axis.domain[1] === null ? formatVal : max([axis.domain[1], formatVal]);\n        }\n    }\n}\n\nexport function configureAxes(state) {\n    if (state.xAxis.scale && !state.xAxis.ordinal.length) {\n        // Infer original X-axis domain\n        let tickLeft = state.xAxis.ticks[0]['ticks'][0].globalPosition['translate'][0];\n        let tickRight = state.xAxis.ticks[state.xAxis.ticks.length - 1]['ticks'][0].globalPosition['translate'][0];\n        \n        // tickLeft = +(tickLeft.hasAttribute(\"transform\") ? tickLeft.getAttribute(\"transform\").match(/(-?\\d+\\.?-?\\d*)/g)[0] : tick_left._global_transform[0] - SVG.state().x_axis.global_range[0]);\n        // tickRight = +(tickRight.hasAttribute(\"transform\") ? tickRight.getAttribute(\"transform\").match(/(-?\\d+\\.?-?\\d*)/g)[0] : tick_right._global_transform[0] - SVG.state().x_axis.global_range[0]);\n\n        let newDomainX = state.xAxis.range.map(\n            state.xAxis.scale.copy().range([tickLeft, tickRight]).invert, state.xAxis.scale\n        );\n        \n        state.xAxis.scale.domain(newDomainX);\n    }\n\n    // TO-DO: Fix transform bug.\n    if (state.yAxis.scale && !state.yAxis.ordinal.length) {\n        // Infer original Y-axis domain\n        let tickBottom = state.yAxis.ticks[0]['ticks'][0].globalPosition['translate'][1];\n        let tickTop = state.yAxis.ticks[state.yAxis.ticks.length - 1]['ticks'][0].globalPosition['translate'][1];\n\n        // tickBottom = +(tickBottom.hasAttribute(\"transform\") ? tickBottom.getAttribute(\"transform\").match(/(-?\\d+\\.?-?\\d*)/g)[1] : tick_bottom._global_transform[1] - SVG.state().y_axis.global_range[1]);\n        // tickTop = +(tickTop.hasAttribute(\"transform\") ? tickTop.getAttribute(\"transform\").match(/(-?\\d+\\.?-?\\d*)/g)[1] : tick_top._global_transform[1] - SVG.state().y_axis.global_range[1]);\n        // tick_bottom = SVG.state().y_axis.global_range[1];\n        // tick_top = SVG.state().y_axis.global_range[0];\n\n        let newDomainY = state.yAxis.range.map(\n            state.yAxis.scale.copy().range([tickTop, tickBottom]).invert, state.yAxis.scale\n        );\n    \n        state.yAxis.scale.domain(newDomainY);\n    }\n}\n","export class Transform {\n    constructor(...args) {\n        if (args[0] instanceof Transform) {\n            const [other] = args;\n            this.translate = [...other.translate];\n            this.scale = [...other.scale];\n            this.rotate = other.rotate;\n        } else {\n            this.translate = [0, 0];\n            this.scale = [0, 0];\n            this.rotate = 0;\n        }\n    }\n}\n","export class ViewState {\n    constructor() {\n        this.hasDomain = false;\n        this.svg = null;\n        this.svgMarks = [];\n        this.textMarks = [];\n        this.axisTextMarks = [];\n\n        this.xAxis = {\n            domain: [null, null],\n            ordinal: [],\n            range: [null, null],\n            globalRange: [null, null],\n            ticks: [],\n            scale: null,\n            axis: null\n        };\n        this.yAxis = {\n            domain: [null, null],\n            ordinal: [],\n            range: [null, null],\n            globalRange: [null, null],\n            ticks: [],\n            scale: null,\n            axis: null\n        };\n        \n        this.legend = [];\n        this.titles = {\n            x: null,\n            y: null\n        };\n        \n        this.interactions = {\n            selection: {\n                control: null,\n                active: false\n            },\n            zoom: {\n                control: null,\n                axisControl: null\n            },\n            pan: {\n                control: null,\n                axisControl: null,\n                flag: false\n            },\n            brush: {\n                control: null,\n                axisControl: null,\n                flag: true,\n                active: false,\n                on_elem: false\n            },\n            filter: {\n                control: null,\n                active: false\n            },\n            sort: {\n                control: null\n            },\n            annotate: {\n                flag: false\n            },\n            arrange: {\n                flag: false\n            }\n        }\n    }\n}\n","export function parseTransform(element, transforms = {translate: [0, 0], scale: [0, 0], rotate: 0}) {\n    const transformList = element.transform.baseVal;\n    \n    for (let i = 0; i < transformList.numberOfItems; ++i) {\n        const transform = transformList.getItem(i);\n        const matrix = transform.matrix;\n\n        switch (transform.type) {\n            case 2:\n                transforms.translate[0] += matrix.e;\n                transforms.translate[1] += matrix.f;\n                break;\n            case 3:\n                transforms.scale[0] += matrix.a;\n                transforms.scale[1] += matrix.d;\n                break;\n            case 4:\n                transforms.rotate += transform.angle;\n                break;\n            default:\n                break;\n        }\n    }\n\n    return transforms;\n}\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n      peg$startRuleFunction  = peg$parsesvg_path,\n\n      peg$c0 = function(data) {\n          if (!data) return [];\n          for (var cmds=[],i=0;i<data.length;i++) cmds=cmds.concat.apply(cmds,data[i]);\n          var first=cmds[0];\n          if (first && first.code=='m'){ // Per spec, first moveto is never relative\n            delete first.relative;\n            first.code = 'M';\n          }\n          return cmds;\n        },\n      peg$c1 = function(first, more) { return merge(first,more) },\n      peg$c2 = /^[Mm]/,\n      peg$c3 = peg$classExpectation([\"M\", \"m\"], false, false),\n      peg$c4 = function(c, first, more) {\n          var move = commands(c,[first]);\n          if (more) move = move.concat(commands(c=='M' ? 'L' : 'l',more[1]));\n          return move;\n        },\n      peg$c5 = /^[Zz]/,\n      peg$c6 = peg$classExpectation([\"Z\", \"z\"], false, false),\n      peg$c7 = function() { return commands('Z') },\n      peg$c8 = /^[Ll]/,\n      peg$c9 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c10 = function(c, args) { return commands(c,args) },\n      peg$c11 = /^[Hh]/,\n      peg$c12 = peg$classExpectation([\"H\", \"h\"], false, false),\n      peg$c13 = function(c, args) { return commands(c,args.map(function(x){ return {x:x}})) },\n      peg$c14 = /^[Vv]/,\n      peg$c15 = peg$classExpectation([\"V\", \"v\"], false, false),\n      peg$c16 = function(c, args) { return commands(c,args.map(function(y){ return {y:y}})) },\n      peg$c17 = /^[Cc]/,\n      peg$c18 = peg$classExpectation([\"C\", \"c\"], false, false),\n      peg$c19 = function(a, b, c) { return { x1:a.x, y1:a.y, x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c20 = /^[Ss]/,\n      peg$c21 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c22 = function(b, c) { return { x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c23 = /^[Qq]/,\n      peg$c24 = peg$classExpectation([\"Q\", \"q\"], false, false),\n      peg$c25 = function(a, b) { return { x1:a.x, y1:a.y, x:b.x, y:b.y } },\n      peg$c26 = /^[Tt]/,\n      peg$c27 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c28 = /^[Aa]/,\n      peg$c29 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c30 = function(rx, ry, xrot, large, sweep, xy) { return { rx:rx, ry:ry, xAxisRotation:xrot, largeArc:large, sweep:sweep, x:xy.x, y:xy.y } },\n      peg$c31 = function(x, y) { return { x:x, y:y } },\n      peg$c32 = function(n) { return n*1 },\n      peg$c33 = function(parts) { return parts.join('')*1 },\n      peg$c34 = /^[01]/,\n      peg$c35 = peg$classExpectation([\"0\", \"1\"], false, false),\n      peg$c36 = function(bit) { return bit=='1' },\n      peg$c37 = function() { return '' },\n      peg$c38 = \",\",\n      peg$c39 = peg$literalExpectation(\",\", false),\n      peg$c40 = function(parts) { return parts.join('') },\n      peg$c41 = \".\",\n      peg$c42 = peg$literalExpectation(\".\", false),\n      peg$c43 = /^[eE]/,\n      peg$c44 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c45 = /^[+\\-]/,\n      peg$c46 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c47 = /^[0-9]/,\n      peg$c48 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c49 = function(digits) { return digits.join('') },\n      peg$c50 = /^[ \\t\\n\\r]/,\n      peg$c51 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsesvg_path() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemoveTo_drawTo_commandGroups();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroups() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveTo_drawTo_commandGroup();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemoveTo_drawTo_commandGroup();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveto();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsedrawto_command();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedrawto_command();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedrawto_command() {\n    var s0;\n\n    s0 = peg$parseclosepath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselineto();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehorizontal_lineto();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevertical_lineto();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecurveto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsesmooth_curveto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsequadratic_bezier_curveto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseelliptical_arc();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveto() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsecomma_wsp();\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parselineto_argument_sequence();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclosepath() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselineto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselineto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehorizontal_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c11.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevertical_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c14.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c17.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecurveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecurveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecurveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecurveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecoordinate_pair();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c19(s1, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c20.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesmooth_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesmooth_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesmooth_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequadratic_bezier_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsequadratic_bezier_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsequadratic_bezier_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c28.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelliptical_arc_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelliptical_arc_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseelliptical_arc_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseelliptical_arc_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonnegative_number();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenonnegative_number();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomma_wsp();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseflag();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecomma_wsp();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseflag();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsecomma_wsp();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsecoordinate_pair();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c30(s1, s3, s5, s7, s9, s11);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_pair() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c31(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonnegative_number() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefloating_point_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsedigit_sequence();\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsefloating_point_constant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedigit_sequence();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c33(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseflag() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c34.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c36(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsecomma_wsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c38;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloating_point_constant() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsefractional_constant();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseexponent();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexponent();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedigit_sequence();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c41;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit_sequence() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c50.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c37();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n\n    function merge(first,more){\n      if (!more) return [first];\n      for (var a=[first],i=0,l=more.length;i<l;i++) a[i+1]=more[i][1];\n      return a;\n    }\n\n    var cmds = {m:'moveto',l:'lineto',h:'horizontal lineto',v:'vertical lineto',c:'curveto',s:'smooth curveto',q:'quadratic curveto',t:'smooth quadratic curveto',a:'elliptical arc',z:'closepath'};\n    for (var code in cmds) cmds[code.toUpperCase()]=cmds[code];\n    function commands(code,args){\n      if (!args) args=[{}];\n      for (var i=args.length;i--;){\n        var cmd={code:code,command:cmds[code]};\n        if (code==code.toLowerCase()) cmd.relative=true;\n        for (var k in args[i]) cmd[k]=args[i][k];\n        args[i] = cmd;\n      }\n      return args;\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","// v1.0 exported just the parser function. To maintain backwards compatibility,\n// we export additional named features as properties of that function.\nvar parserFunction = require('./parser.js').parse;\nparserFunction.parseSVG = parserFunction;\nparserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;\nmodule.exports = parserFunction;\n\nfunction makeSVGPathCommandsAbsolute(commands) {\n\tvar subpathStart, prevCmd={x:0,y:0};\n\tvar attr = {x:'x0',y:'y0',x1:'x0',y1:'y0',x2:'x0',y2:'y0'};\n\tcommands.forEach(function(cmd) {\n\t\tif (cmd.command==='moveto') subpathStart=cmd;\n\t\tcmd.x0=prevCmd.x; cmd.y0=prevCmd.y;\n\t\tfor (var a in attr) if (a in cmd) cmd[a] += cmd.relative ? cmd[attr[a]] : 0;\n\t\tif (!('x' in cmd)) cmd.x = prevCmd.x; // V\n\t\tif (!('y' in cmd)) cmd.y = prevCmd.y; // X\n\t\tcmd.relative = false;\n\t\tcmd.code = cmd.code.toUpperCase();\n\t\tif (cmd.command=='closepath') {\n\t\t\tcmd.x = subpathStart.x;\n\t\t\tcmd.y = subpathStart.y;\n\t\t}\n\t\tprevCmd = cmd;\n\t});\n\treturn commands;\n}\n","import {\n    SvgContainer, SvgGroup, Tick, TickDomain, Background, \n    Foreground, Grid, Label, Circle, Ellipse, Line, Polygon, \n    Polyline, Rect, Path, Text\n} from '../state/constants.js';\n\nimport { Transform } from '../util/transform.js';\nimport { ViewState } from '../state/view-state.js';\nimport { parseTransform } from '../util/attribute-parsers';\nimport * as parser from 'svg-path-parser';\n\nconst markTypes = [Circle, Ellipse, Line, Polygon, Polyline, Rect, Path];\n\nfunction extractElementInformation(element, transform) {\n    element.relativePosition = parseTransform(element);\n    element.globalPosition = parseTransform(element, new Transform(transform));\n    \n    const clientRect = element.getBoundingClientRect();\n    element.clientRect = {\n        left: +clientRect.left,\n        right: +clientRect.right,\n        top: +clientRect.top,\n        bottom: +clientRect.bottom\n    }\n}\n\nfunction inferTypeFromPath(element) { \n    let commands = parser.parseSVG(element.getAttribute('d'));\n    if (!commands.length) return;\n\n    element.contour = commands;\n    let endCmd = commands[commands.length - 1];\n\n    if (commands.length === 3 && commands[1].code === 'A' && endCmd.code === 'A') {\n        element.type = Ellipse;\n    } else if (endCmd.code !== 'Z') {\n        element.type = Line;\n    } else {\n        element.type = Polygon;\n    }\n}\n\nfunction analyzeAxis(element, state, transform) {\n    if (!element) return;\n\n    if (element.nodeName === SvgGroup) {\n        parseTransform(element, transform);\n    } else if (element.nodeName === Text) {\n        extractElementInformation(element, transform);\n        state.axisTextMarks.push(element);\n        element.style['pointer-events'] = 'none';\n        element.style['user-select'] = 'none';\n    } else if (markTypes.includes(element.nodeName)) {\n        extractElementInformation(element, transform);\n        let isX = element.hasAttribute('x2') ? +element.getAttribute('x2') : 0;\n        isX = !isX ? Math.abs(element.clientRect.bottom - element.clientRect.top) < 1 : isX;\n        \n        let isY = element.hasAttribute('y2') ? +element.getAttribute('y2') : 0;\n        isY = !isY ? Math.abs(element.clientRect.left - element.clientRect.right) < 1 : isY;\n\n        if (isX) state.xAxis.ticks.push(element);\n        if (isY) state.yAxis.ticks.push(element);\n    }\n\n    for (const child of element.childNodes) {\n        analyzeAxis(child, state, new Transform(transform));\n    }\n}\n\nfunction analyzeDomTree(element, state, transform) {\n    if (!element) return;\n    if (element.className && (element.className.baseVal === Background || \n        element.className.baseVal === Foreground)) return;\n    var skip = false;\n\n    if (element.nodeName === SvgContainer) {\n        extractElementInformation(element, transform);\n        state.svg = element;\n    } else if (element.nodeName === SvgGroup) {\n        parseTransform(element, transform);\n\n        let cName = element.className.baseVal;\n        if (cName.includes(Tick) || cName.includes(Grid) || cName.includes(Label) /*|| c_name.includes(\"title\")*/) {\n            skip = true;\n            for (const child of element.childNodes) {\n                analyzeAxis(child, state, new Transform(transform));\n            }\n        }\n    } else if (element.nodeName === Text) {\n        extractElementInformation(element, transform);\n        state.textMarks.push(element);\n        element.style['pointer-events'] = 'none';\n        element.style['user-select'] = 'none';\n    } else if (markTypes.includes(element.nodeName)) {\n        extractElementInformation(element, transform);\n        const markType = element.nodeName;\n\n        if (markType === Path) {\n            // if (!element.hasAttribute('d')) continue;\n            inferTypeFromPath(element);\n        } else if (markType === Polyline) {\n            element.type = Polyline\n        }\n\n        if (element.className && element.className.baseVal === TickDomain) {\n            state.hasDomain = true;\n        } else {\n            element.setAttribute('__mark__', 'true');\n            state.svgMarks.push(element);\n        }\n    }\n\n    if (!skip) {\n        for (const child of element.childNodes) {\n            analyzeDomTree(child, state, new Transform(transform));\n        }\n    }\n}\n\nexport function inspect(svg) {\n    let state = new ViewState();\n    analyzeDomTree(svg, state, new Transform());\n    console.log(state);\n    return state;\n}\n","import { \n    Selection, Zoom, Pan, Brush, Filter, Sort, \n    Annotate, Arrange, Path, Ellipse\n} from '../state/constants.js';\n\nimport { groupLabels, groupAxis, computeDomain, \n    configureAxes \n} from '../util/axis-parsers.js';\n\nimport { groupLegend } from '../util/legend-parsers.js';\nimport { min, max } from 'd3-array';\nimport { axisBottom, axisLeft } from '../_d3/axis';\n\nimport { inspect } from './inspect.js';\n// import { select } from '../handlers/select.js';\n// import { zoom } from '../handlers/zoom.js';\n// import { brush } from '../handlers/brush.js';\n// import { filter } from '../handlers/filter.js';\n// import { sort } from '../handlers/sort.js';\n// import { annotate } from '../handlers/annotate.js';\n// import { arrange } from '../handlers/arrange.js';\n\nexport function orchestrate(svg) { \n    var state = inspect(svg);\n    initialize();\n\n    function initialize() {\n        // state.svg.style['cursor'] = 'crosshair';\n\n        // Initialize interactions\n        // select(state);\n        // zoom(state);\n        // brush(state);\n        // filter(state);\n        // sort(state);\n        // annotate(state);\n        // arrange(state);\n\n        // Infer view information\n        analyzeAxes();\n        // inferMarkAttributes();\n        // inferView();\n    }\n\n    function analyzeAxes() {\n        groupAxis(state.xAxis, 'left');\n        groupAxis(state.yAxis, 'top');\n        groupLabels(state);\n        groupLegend(state);\n    }\n\n    function inferMarkAttributes() { \n        for (const mark of state.svgMarks) {\n            if (mark.nodeName !== Path || (!state.xAxis.ticks.length && !state.yAxis.ticks.length) || \n               (mark.nodeName === Path && mark.type === Ellipse)) {\n                if (mark.__data__) {\n                    if (typeof mark.__data__ === 'string' || typeof mark.__data__ === 'number') {\n                        var iterable = mark.__data__;\n                        break;\n                    }\n    \n                    let hasDatum = 'datum' in mark.__data__;\n                    let hasProperties = 'properties' in mark.__data__;\n                    let hasData = 'data' in mark.__data__;\n                \n                    var iterable = hasDatum \n                    ? mark.__data__.datum : hasProperties \n                    ? mark.__data__.properties : hasData \n                    ? mark.__data__.data : mark.__data__;\n                } else {\n                    let markX = (mark.clientRect.left + mark.clientRect.right) / 2\n                        - state.xAxis.ticks[0]['ticks'][0].parentNode._global_transform[0]\n                        - state.svg.clientRect.left;\n                    let markY = (mark.clientRect.top + mark.clientRect.bottom) / 2\n                        - state.yAxis.ticks[0]['ticks'][0].parentNode._global_transform[1]\n                        - state.svg.clientRect.top;\n    \n                    var iterable = {\n                        [state.titles.x.innerHTML]: state.xAxis.scale.invert(markX).toFixed(2),\n                        [state.titles.y.innerHTML]: state.yAxis.scale.invert(markY).toFixed(2)\n                    }\n                }\n\n                mark.style['pointer-events'] = 'fill';\n                mark.__inferred__data__ = iterable;\n            }\n        }\n    }\n\n    function inferView() {\n        computeDomain(state.xAxis);\n        computeDomain(state.yAxis);\n    \n        const width = +state.svg.getAttribute('width');\n        const height = +state.svg.getAttribute('height');\n    \n        if (!state.xAxis.ticks.length && !state.yAxis.ticks.length) {\n            state.xAxis.range = state.xAxis.globalRange = [0, width];\n            state.yAxis.range = state.yAxis.globalRange = [height, 0];\n            return;\n        }\n        \n        // TO-DO: Domain path 0.5 difference.\n        if (state.hasDomain) {\n            let axes = [].slice.call(state.svg.querySelectorAll(\".domain\")).map((d) => { return d.getBoundingClientRect() });\n            let y_axis = axes[0].width < axes[1].width ? axes[0] : axes[1];\n            let x_axis = axes[0].height < axes[1].height ? axes[0] : axes[1];\n    \n            var x_min = x_axis.left - state.svg.getBoundingClientRect().left;\n            var x_max = x_axis.right - state.svg.getBoundingClientRect().left;\n    \n            var y_max = y_axis.bottom - state.svg.getBoundingClientRect().top;\n            var y_min = y_axis.top - state.svg.getBoundingClientRect().top;\n        } else {\n            let y_tick = state.y_axis.ticks[0]['ticks'][0].getBoundingClientRect();\n            let x_tick = state.x_axis.ticks[0]['ticks'][0].getBoundingClientRect();\n    \n            if (y_tick.right < x_tick.left) {\n                var x_min = y_tick.right - state.svg.getBoundingClientRect().left;\n                var x_max = width;\n            } else {\n                var x_min = y_tick.left - state.svg.getBoundingClientRect().left;\n                var x_max = d3.min([y_tick.width + x_min, width]);\n            }\n    \n            if (x_tick.top > y_tick.bottom) {\n                var y_max = x_tick.top - state.svg.getBoundingClientRect().top;\n                var y_min = 0;\n            } else {\n                var y_max = x_tick.bottom - state.svg.getBoundingClientRect().top;\n                var y_min = d3.max([y_max - x_tick.height, 0]);\n            }\n        }\n    \n        //     var x_min = d3.min(state.y_axis.ticks[0]['ticks'].map(d => d.getBoundingClientRect().left - state.svg.getBoundingClientRect().left));\n        //     var x_max = d3.min([d3.max(state.y_axis.ticks[0]['ticks'].map(d => d.getBoundingClientRect().width + x_min)), width]);\n    \n        //     var y_max = d3.max(state.x_axis.ticks[0]['ticks'].map(d => d.getBoundingClientRect().bottom - state.svg.getBoundingClientRect().top));\n        //     var y_min = d3.max([d3.min(state.x_axis.ticks[0]['ticks'].map(d => y_max - d.getBoundingClientRect().height)), 0]);\n        // }\n    \n    \n        // state.x_axis.range = [x_min, x_max].map(d => d - state.x_axis.ticks[0]['ticks'][0]._global_transform[0]);\n        // state.y_axis.range = [y_max, y_min].map(d => d - state.y_axis.ticks[0]['ticks'][0]._global_transform[1]);\n        state.x_axis.global_range = [x_min, x_max];\n        state.y_axis.global_range = [y_max, y_min];\n        state.x_axis.range = [x_min, x_max].map(d => d - state.x_axis.ticks[0]['ticks'][0].parentNode._global_transform[0]);\n        state.y_axis.range = [y_max, y_min].map(d => d - state.y_axis.ticks[0]['ticks'][0].parentNode._global_transform[1]);\n    \n        let diff_1_y = +state.y_axis.ticks[1]['label'].innerHTML - +state.y_axis.ticks[0]['label'].innerHTML;\n        let diff_2_y = +state.y_axis.ticks[2]['label'].innerHTML - +state.y_axis.ticks[1]['label'].innerHTML;\n    \n        let diff_1_x = +state.x_axis.ticks[1]['label'].innerHTML - +state.x_axis.ticks[0]['label'].innerHTML;\n        if (state.x_axis.ticks.length < 3) {\n            var diff_2_x = 0;\n        } else {\n            var diff_2_x = +state.x_axis.ticks[2]['label'].innerHTML - +state.x_axis.ticks[1]['label'].innerHTML;\n        }\n    \n        let diff_tick_a = state.x_axis.ticks[1]['ticks'][0].getBoundingClientRect().left - \n            state.x_axis.ticks[0]['ticks'][0].getBoundingClientRect().left;\n    \n        if (state.x_axis.ticks.length < 3) {\n            var diff_tick_b = 0;\n        } else {\n            var diff_tick_b = state.x_axis.ticks[2]['ticks'][0].getBoundingClientRect().left - \n                state.x_axis.ticks[1]['ticks'][0].getBoundingClientRect().left;\n        }\n    \n        if (Math.abs(diff_1_x - diff_2_x) > 5e-1 || Math.abs(diff_tick_a - diff_tick_b) > 5e-1) {\n            // let tick_diff_1 = state.x_axis.ticks['ticks'][1].getBoundingClientRect().left - \n            //     state.x_axis.ticks['ticks'][0].getBoundingClientRect().left;\n            // let tick_diff_2 = state.x_axis.ticks['ticks'][2].getBoundingClientRect().left - \n            //     state.x_axis.ticks['ticks'][1].getBoundingClientRect().left;\n    \n            if (Math.abs(diff_tick_a - diff_tick_b) < 5e-1) {\n                let format = state.x_axis.ticks['ticks'][0].childNodes[1].innerHTML;\n                if (format != state.x_axis.ticks[0].__data__ && typeof format === \"string\") { \n                    var exponent = format.match(/^(e|\\d+)\\^(e|\\d+)$/);\n                    var superscript = format.match(/^(e|d+)([\\u2070-\\u209F\\u00B2\\u00B3\\u00B9])$/);\n                    if (exponent) {\n                        var base = exponent[1];\n                        base = (base === 'e' ? Math.E : parseInt(base));\n                    } else if (superscript) {\n                        var base = superscript[1];\n                        base = (base === 'e' ? Math.E : parseInt(base));\n                    }\n                }\n            } \n            \n            function format(d) {\n                function digitToSuperscript(superChar) {\n                    let table = \"⁰¹²³⁴⁵⁶⁷⁸⁹\";\n                    return table[superChar];\n                }\n    \n                let exp = Math.log(d) / Math.log(base);\n                return superscript ? 'e' + String(exp).replace(/\\d/g, digitToSuperscript) : d + '^' + exp;\n            }\n    \n            state.x_axis.scale = d3.scaleLog()\n                .domain(state.x_axis.domain)\n                .range(state.x_axis.range);\n            state.x_axis.axis = axisBottom(state.x_axis.scale, SVG)\n                // .tickSize(state.x_axis.ticks[1].children[0].getAttribute(\"y2\"))\n                .ticks(state.x_axis.ticks.filter(d => d['label'].innerHTML).length)\n            if (base) {\n                state.x_axis.scale = state.x_axis.scale.base(base);\n                state.x_axis.axis = state.x_axis.axis.tickFormat(d => exponent || superscript ? format(d) : d);\n            }\n        } else {\n            state.x_axis.scale = (state.x_axis.domain[0] instanceof Date ? d3.scaleTime() : (state.x_axis.ordinal.length ? d3.scaleBand() : d3.scaleLinear()))\n                .domain(state.x_axis.ordinal.length ? state.x_axis.ordinal : state.x_axis.domain)\n                .range(state.x_axis.range)\n            // state.x_axis.scale = (state.x_axis.domain[0] instanceof Date ? d3.scaleTime() : d3.scaleLinear())\n            //     .domain(state.x_axis.ordinal.length ? state.x_axis.range : state.x_axis.domain)\n            //     .range(state.x_axis.range);\n            state.x_axis.axis = axisBottom(state.x_axis.scale, SVG)\n                .ticks(state.x_axis.ticks.length);\n            // state.x_axis.axis(state.x_axis.ticks);\n                // .tickSize(state.x_axis.ticks[1].children[0].getAttribute(\"y2\"))\n                // .ticks(typeof x_axis.ticks[0].__data__ === \"string\" ? state.x_axis.ordinal.length : state.x_axis.ticks.length);\n        }\n    \n        if (Math.abs(diff_1_y - diff_2_y) > 5e-1) {\n            state.y_axis.scale = d3.scaleLog()\n                .domain(state.y_axis.domain)\n                .range(state.y_axis.range);\n            state.y_axis.axis = d3.axisLeft(state.y_axis.scale)\n                .tickSize(-state.y_axis.ticks[1].children[0].getAttribute(\"x2\"))\n                .ticks(state.y_axis.ticks.length);\n        } else {\n            state.y_axis.scale = (state.y_axis.domain[0] instanceof Date ? d3.scaleTime() : (state.y_axis.ordinal.length ? d3.scaleBand() : d3.scaleLinear()))\n                .domain(state.y_axis.ordinal.length ? state.y_axis.ordinal : state.y_axis.domain)\n                .range(state.y_axis.range);\n            state.y_axis.axis = axisLeft(state.y_axis.scale, SVG)\n                .ticks(state.y_axis.ticks.length)\n                .tickFormat(d => {\n                    let s = state.y_axis.ticks[0]['label'].innerHTML;\n                    return s.includes(\"M\") || s.includes(\"k\") ? d3.format(\".2s\")(d) : d3.format(\",\")(d);\n                });\n            // state.y_axis.axis(state.y_axis.ticks);\n                // .tickSize(-state.y_axis.ticks[1].children[0].getAttribute(\"x2\"))\n                // .ticks(typeof state.y_axis.ticks[0].__data__ === \"string\" ? state.y_axis.ordinal.length : state.y_axis.ticks.length);\n        }\n    \n        configure_axes();\n    }\n}\n\n//    function filter(x, y, width, height, append=false) {\n//         document.getElementById(\"filter_mode\").style['opacity'] = 1;\n//         document.getElementById(\"filter_mode\").style['display'] = 'block';\n    \n//         for (const mark of state.svg_marks) {\n//             if (mark.style[\"visibility\"] === \"hidden\" || mark.hasAttribute(\"__legend__\")) continue;\n    \n//             if ((mark.type === \"line\" || mark.type === \"polygon\" || mark.type === \"polyline\") && state.x_axis.ticks.length && state.y_axis.ticks.length) {\n//                 state.interactions.brush.active = true;\n//                 select.applyBrush(SVG, x, y, width, height);\n//                 return;\n//             }\n            \n//             if (state.x_axis.ordinal.length || (!state.x_axis.ticks.length && !state.y_axis.ticks.length)) {\n//                 var brush_x_start = x;\n//                 var brush_x_end = x + +width;\n//                 var brush_y_end = y + +height;\n//                 var brush_y_start = y;\n    \n//                 let bb = mark.getBoundingClientRect();\n//                 var data_x = (+bb.left + +bb.right) / 2;\n//                 var data_y = (+bb.top + +bb.bottom) / 2;\n//             } else {\n//                 var brush_x_start = state.x_axis.scale.invert(x);\n//                 var brush_x_end = state.x_axis.scale.invert(x + +width);\n//                 var brush_y_end = state.y_axis.scale.invert(y);\n//                 var brush_y_start = state.y_axis.scale.invert(y + +height);\n    \n//                 let bb = mark.getBoundingClientRect();\n//                 var data_x = (state.x_axis.scale.invert(+bb.left) + state.x_axis.scale.invert(+bb.right)) / 2;\n//                 var data_y = (state.y_axis.scale.invert(+bb.top) + state.y_axis.scale.invert(+bb.bottom)) / 2;\n//             }\n    \n//             if (data_x < brush_x_start || data_x > brush_x_end || data_y < brush_y_start || data_y > brush_y_end) {\n//                 if (!append) {\n//                     mark.setAttribute(\"opacity\", 0.25);\n//                 }\n//             } else {\n//                 mark.setAttribute(\"opacity\", 1);\n//             }\n//         }\n//     }\n\n\n    //     // Tooltip\n    //     let mousedown = false;\n    //     state.svg.addEventListener('mousedown', function(event) {\n    //         mousedown = true;\n    //     });\n    //     state.svg.addEventListener('mouseup', function(event) {\n    //         mousedown = false;\n    //     });\n    //     state.svg.addEventListener('mousemove', function(event) {\n    //         if (!mousedown) document.getElementById(\"modebar\").style['visibility'] = 'visible';\n\n    //         if (state.interactions.pan.flag) {\n    //             let left_bound = state.svg_marks[0]._global_transform[0] + SVG.state().svg.getBoundingClientRect().left;\n    //             let top_bound = state.svg_marks[0]._global_transform[1] + SVG.state().svg.getBoundingClientRect().top;\n\n    //             let x_axis = event.clientX - left_bound > state.x_axis.range[0], \n    //                 y_axis = event.clientY - top_bound < state.y_axis.range[0];\n\n    //             state.svg.style['cursor'] = x_axis && !y_axis ? 'ew-resize' :\n    //                 !x_axis && y_axis ? 'ns-resize' : 'move';\n    //         }\n    //     });\n    //     state.svg.addEventListener('mouseleave', function(event) {\n    //         if (event.clientX <= +state.svg.getBoundingClientRect().left || event.clientX >= +state.svg.getBoundingClientRect().right) {\n    //             document.getElementById(\"modebar\").style['visibility'] = 'hidden';\n    //         }\n    //     });\n\n    //     let pan_elem = document.getElementById(\"pan_mode\");\n    //     let brush_elem = document.getElementById(\"brush_mode\");\n    //     let filter_elem = document.getElementById(\"filter_mode\");\n    //     let annotate_elem = document.getElementById(\"annotate_mode\");\n\n    //     pan_elem.addEventListener(\"click\", function(event) {\n    //         if (state.svg.parentNode.style['visibility'] === 'hidden') return;\n\n    //         pan_elem.style['opacity'] = +pan_elem.style['opacity'] === 0.4 ? 1 : 0.4;\n    //         brush_elem.style['opacity'] = 0.4;\n    //         annotate_elem.style['opacity'] = 0.4;\n\n    //         state.interactions.pan.flag = !state.interactions.pan.flag;\n    //         state.interactions.brush.flag = false;\n    //         state.interactions.annotate.flag = false;\n    //         state.svg.style['cursor'] = 'move';\n\n    //         // document.getElementById(\"logfile\").innerHTML += \"Click \" + state.svg.id + \" \" +\n    //             // (+pan_elem.style['opacity'] === 0.4 ? \"disable\" : \"enable\") + \" pan <br/>\";\n    //     });\n    //     brush_elem.addEventListener(\"click\", function(event) {\n    //         if (state.svg.parentNode.style['visibility'] === 'hidden') return;\n\n    //         brush_elem.style['opacity'] = +brush_elem.style['opacity'] === 0.4 ? 1 : 0.4;\n    //         pan_elem.style['opacity'] = 0.4;\n    //         annotate_elem.style['opacity'] = 0.4;\n\n    //         state.interactions.annotate.flag = false;\n    //         state.interactions.pan.flag = false;\n    //         state.interactions.brush.flag = !state.interactions.brush.flag;\n    //         state.svg.style['cursor'] = 'crosshair';\n\n    //         // document.getElementById(\"logfile\").innerHTML += \"Click \" + state.svg.id + \" \" +\n    //             // (+brush_elem.style['opacity'] === 0.4 ? \"disable\" : \"enable\") + \" brush <br/>\";\n    //     });\n\n    //     filter_elem.addEventListener(\"click\", function(event) {\n    //         if (state.svg.parentNode.style['visibility'] === 'hidden') return;\n            \n    //         // let append = false;\n    //         // for (const mark of state.svg_marks) {\n    //         //     if (mark.style['visibility'])\n    //         // }\n    //         // if (!state.interactions.filter.active || !document.querySelectorAll('[visibility=\"hidden\"]')) {\n    //             state.interactions.filter.active = !state.interactions.filter.active;\n    //             state.interactions.brush.flag = false;\n    //         state.interactions.annotate.flag = false;\n    //         // } \n    //         let el;\n    //         for (const mark of state.svg_marks) {\n    //             if (mark.hasAttribute(\"__legend__\")) continue;\n    //             mark.style['visibility'] = state.interactions.filter.active ? \n    //                 +mark.getAttribute(\"opacity\") === 1 ? 'visible' : 'hidden'\n    //                 : 'visible'\n    //             if (mark.style['visibility'] === 'visible') el = mark;\n\n    //             // for (const tick of state.x_axis.ticks) {\n    //             //     let offset = (+mark.getBoundingClientRect().left + +mark.getBoundingClientRect().right) / 2;\n    //             //     let t_offset = (+tick['ticks'][0].getBoundingClientRect().left + +tick['ticks'][0].getBoundingClientRect().right) / 2;\n    //             //     let l_offset = (+tick['label'].getBoundingClientRect().left + +tick['label'].getBoundingClientRect().right) / 2;\n    //             //     if (Math.abs(offset - t_offset) < 1 && mark.style['visibility'] !== 'visible') {\n    //             //         // tick['label'].style['visibility'] = 'hidden';\n    //             //         tick['ticks'][0].style['visibility'] = 'hidden';\n    //             //     }\n    //             //     if (Math.abs(offset - l_offset) < 20 && mark.style['visibility'] !== 'visible') {\n    //             //         tick['label'].style['visibility'] = 'hidden';\n    //             //     }\n    //             // }\n    //         }\n    //         console.log(el)\n\n    //         // for (const l of state.legend) {\n    //         //     console.log(l)\n    //         //     if (window.getComputedStyle(l['glyph']).fill !== window.getComputedStyle(el).stroke) {\n    //         //         l['label'].setAttribute(\"opacity\", 0);\n    //         //         l['glyph'].setAttribute(\"opacity\", 0);\n    //         //     } else {\n    //         //         l['label'].setAttribute(\"opacity\", 1);\n    //         //         l['glyph'].setAttribute(\"opacity\", 1);\n    //         //         l['label'].style['visibility'] = 'visible';\n    //         //         l['glyph'].style['visibility'] = 'visible';\n    //         //     }\n    //         // }\n\n    //         // document.getElementById(\"logfile\").innerHTML += \"Click \" + state.svg.id + \" \" +\n    //             // (state.interactions.filter.active ? \"enable\" : \"disable\") + \" filter <br/>\";\n    //     });\n    //     annotate_elem.addEventListener(\"click\", function(event) {\n    //         if (state.svg.parentNode.style['visibility'] === 'hidden') return;\n\n    //         annotate_elem.style['opacity'] = +annotate_elem.style['opacity'] === 0.4 ? 1 : 0.4;\n    //         pan_elem.style['opacity'] = 0.4;\n    //         brush_elem.style['opacity'] = 0.4;\n\n    //         state.interactions.brush.flag = false;\n    //         state.interactions.pan.flag = false;\n    //         state.interactions.annotate.flag = !state.interactions.annotate.flag;\n    //         state.svg.style['cursor'] = 'pointer';\n\n    //         // +annotate_elem.style['opacity'] === 0.4 ? annotate.unbind() : annotate.bind(SVG);\n    //         // document.getElementById(\"logfile\").innerHTML += \"Click \" + state.svg.id + \" \" +\n    //             // (+annotate_elem.style['opacity'] === 0.4 ? \"disable\" : \"enable\") + \" annotate <br/>\";\n    //     });\n    // }\n\n    // unfilter = function() {\n    //     state.interactions.brush.active = false;\n    //     let append = false;\n    \n    //     for (const mark of state.svg_marks) {\n    //         mark.style[\"visibility\"] === \"hidden\" ? append = true : mark.setAttribute(\"opacity\", 1);\n    //     }\n    //     if (!append) document.getElementById(\"filter_mode\").style['display'] = 'none';\n    // }\n","export function groupLegend(state) {\n    let titleX, titleY,\n        minX = 10000, maxY = 0;\n    for (const text of state.textMarks) {\n        if (text.clientRect.left < minX) {\n            minX = text.clientRect.left;\n            titleY = text;\n        }\n        if (text.clientRect.bottom > maxY) {\n            maxY = text.clientRect.bottom;\n            titleX = text;\n        }\n    }\n\n    if (titleY && Math.abs(minX - state.svg.clientRect.left) < 50) {\n        titleY.__title__ = true;\n        state.titles.y = titleY;\n    }\n    if (titleX && Math.abs(maxY - state.svg.clientRect.bottom) < 50) {\n        titleX.__title__ = true;\n        state.titles.x = titleX;    \n    } \n\n    for (const text of state.textMarks) {\n        if (text.__title__) continue;\n\n        let textX = (text.clientRect.left + text.clientRect.right) / 2,\n            textY = (text.clientRect.top + text.clientRect.bottom) / 2;\n        let minPos = 10000, minMark;\n\n        for (const mark of state.svgMarks) {\n            let markX = (mark.clientRect.left + mark.clientRect.right) / 2,\n                markY = (mark.clientRect.bottom + mark.clientRect.bottom) / 2;\n            // let diff = Math.abs(mark_x - text_x) + Math.abs(mark_y - text_y);\n            let diff = Math.abs(markX - textX) + Math.abs(markY - textY);\n\n            if (diff < minPos) {\n                minPos = diff;\n                minMark = mark;\n            }\n        }\n\n        minMark.removeAttribute('__mark__');\n        text.setAttribute('__legend__', true);\n        minMark.setAttribute('__legend__', 'true');\n        // min_mark.style['pointer-events'] = 'fill';\n        // console.log(min_mark)\n        state.legend.push({'label': text, 'glyph': minMark});\n    }\n}\n","import { orchestrate } from './orchestration/orchestrate';\n\nexport function hydrate(svg) {\n    if (typeof svg === \"string\") svg = document.querySelector(svg);\n    if (svg) orchestrate(svg);\n}\n"],"names":["Tick","Ellipse","Line","Polygon","Polyline","Path","Text","groupAxis","axis","index","positionMap","i","ticks","length","offset","clientRect","setAttribute","push","label","key","value","Object","entries","sort","first","second","Transform","constructor","args","other","this","translate","scale","rotate","ViewState","hasDomain","svg","svgMarks","textMarks","axisTextMarks","xAxis","domain","ordinal","range","globalRange","yAxis","legend","titles","x","y","interactions","selection","control","active","zoom","axisControl","pan","flag","brush","on_elem","filter","annotate","arrange","parseTransform","element","transforms","transformList","transform","baseVal","numberOfItems","getItem","matrix","type","e","f","a","d","angle","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","child","parent","ctor","prototype","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","escapedParts","parts","Array","classEscape","inverted","any","end","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","j","descriptions","slice","join","describeExpected","describeFound","parserFunction","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","svg_path","peg$parsesvg_path","peg$startRuleFunction","peg$c1","more","l","merge","peg$c2","peg$c3","peg$classExpectation","peg$c5","peg$c6","peg$c8","peg$c9","peg$c10","c","commands","peg$c11","peg$c12","peg$c14","peg$c15","peg$c17","peg$c18","peg$c20","peg$c21","peg$c23","peg$c24","peg$c26","peg$c27","peg$c28","peg$c29","peg$c34","peg$c35","peg$c39","peg$literalExpectation","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c50","peg$c51","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","startRule","ignoreCase","peg$computePosDetails","pos","p","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","start","peg$fail","s0","s1","s2","s3","s4","peg$parsewsp","s5","peg$parsemoveTo_drawTo_commandGroup","peg$parsemoveTo_drawTo_commandGroups","data","cmds","concat","apply","code","relative","peg$c0","s6","test","charAt","peg$parsecoordinate_pair","peg$parsecomma_wsp","peg$parselineto_argument_sequence","move","peg$parsemoveto","peg$parsedrawto_command","peg$parseclosepath","peg$parselineto","peg$parsecoordinate_sequence","map","peg$parsehorizontal_lineto","peg$parsevertical_lineto","peg$parsecurveto_argument","peg$parsecurveto_argument_sequence","peg$parsecurveto","peg$parsesmooth_curveto_argument","peg$parsesmooth_curveto_argument_sequence","peg$parsesmooth_curveto","peg$parsequadratic_bezier_curveto_argument","peg$parsequadratic_bezier_curveto_argument_sequence","peg$parsequadratic_bezier_curveto","peg$parsesmooth_quadratic_bezier_curveto_argument_sequence","peg$parsesmooth_quadratic_bezier_curveto","peg$parseelliptical_arc_argument","peg$parseelliptical_arc_argument_sequence","peg$parseelliptical_arc","peg$parsenumber","b","x1","y1","x2","y2","s7","s8","s9","s10","s11","xy","peg$parsenonnegative_number","peg$parseflag","rx","ry","xAxisRotation","largeArc","sweep","peg$parsefloating_point_constant","peg$parsedigit_sequence","peg$parsesign","peg$parsecomma","peg$parsefractional_constant","peg$parseexponent","m","h","v","q","t","z","cmd","command","k","toLowerCase","parseSVG","makeAbsolute","subpathStart","prevCmd","attr","forEach","x0","y0","svgPathParser","markTypes","extractElementInformation","relativePosition","globalPosition","getBoundingClientRect","left","right","top","bottom","analyzeAxis","state","nodeName","style","includes","isX","hasAttribute","getAttribute","Math","abs","isY","childNodes","analyzeDomTree","className","skip","cName","markType","parser.parseSVG","contour","endCmd","inferTypeFromPath","orchestrate","console","log","inspect","xOffset","yOffset","xMin","yMin","groupLabels","titleX","titleY","minX","maxY","__title__","minMark","textX","textY","minPos","mark","markX","markY","diff","removeAttribute","glyph","groupLegend","document","querySelector"],"mappings":"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"}